<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bst_skeleton &#8212; Binary Search Tree 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Binary Search Tree 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Binary Search Tree 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for bst_skeleton</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3</span>

<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="k">import</span> <span class="o">*</span>

<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../index.html#bst_skeleton.Node">[docs]</a><span class="k">class</span> <span class="nc">Node</span><span class="p">():</span>
	<span class="sd">&quot;&quot;&quot; A tree element.</span>

<span class="sd">	:ivar key: the key value</span>
<span class="sd">	:ivar left: reference to the left child</span>
<span class="sd">	:ivar right: reference to the right child</span>
<span class="sd">	:ivar parent: reference to the parent</span>
<span class="sd">	:ivar depth: depth of the node</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Initializes a new node &quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span>

	
<div class="viewcode-block" id="Node.add_left"><a class="viewcode-back" href="../index.html#bst_skeleton.Node.add_left">[docs]</a>	<span class="k">def</span> <span class="nf">add_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Helper function: create a L child  &quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
		<span class="n">left</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
		<span class="n">left</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Node.add_right"><a class="viewcode-back" href="../index.html#bst_skeleton.Node.add_right">[docs]</a>	<span class="k">def</span> <span class="nf">add_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Helper function: create a R child  &quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
		<span class="n">right</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
		<span class="n">right</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span></div>

	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="BinaryTree"><a class="viewcode-back" href="../index.html#bst_skeleton.BinaryTree">[docs]</a><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">():</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A binary tree implementation.</span>
<span class="sd">	</span>
<span class="sd">	.. _root:</span>

<span class="sd">	:ivar root: a reference to the root node</span>
<span class="sd">	:ivar height: the height of the tree (length of a path from the root to a leaf)</span>

<span class="sd">	.. _description:</span>

<span class="sd">	The methods to be implemented in this module  (preorder_walk_, postorder_walk_, is_bst_) essentially use recursion to accomplish their task, but the purely recursive part is nested into the method, that takes care of bootstrapping  the inner procedure, providing the actual parameters for the top call. The general outline of these functions follows.</span>


<span class="sd">	.. code-block:: python</span>

<span class="sd">		def my_method( self, ... ):</span>
<span class="sd">		</span>
<span class="sd">			def inner_recursive_procedure( node, ... ):</span>
<span class="sd">				# recursive blah</span>
<span class="sd">		</span>
<span class="sd">			return inner_recursive_procedure( self.root, ... )</span>

<span class="sd">	Note that the nested procedure &quot;captures&quot; any variable created in the scope of the wrapper procedure. If you need to update a data structure across the recursive calls, the following is valid.</span>

<span class="sd">	.. code-block:: python</span>

<span class="sd">		def my_method( self, ... ):</span>
<span class="sd">		</span>
<span class="sd">			lst = []</span>
<span class="sd">		</span>
<span class="sd">			def inner_recursive_procedure( node, ... ):</span>
<span class="sd">				# recursive stuff that modifies lst</span>
<span class="sd">			</span>
<span class="sd">			inner_recursive_procedure( self.root, ... )</span>
<span class="sd">			</span>
<span class="sd">			return lst</span>


<span class="sd">	You can accomplish the same thing in a cleaner, more functional style, where the data structure is constructed, and returned by the recursive procedure:</span>

<span class="sd">	.. code-block:: python</span>
<span class="sd">		</span>
<span class="sd">		def my_method( self, ...):</span>
<span class="sd">			</span>
<span class="sd">			def inner_recursive_procedure( node, lst, ... ):</span>
<span class="sd">				# recursive stuff build a new list from lst, and return a new list</span>

<span class="sd">			return inner_recursive_procedure(self.root, [], ...)</span>

<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="BinaryTree.__init__"><a class="viewcode-back" href="../index.html#bst_skeleton.BinaryTree.__init__">[docs]</a>	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Initializes an empty tree </span>
<span class="sd">		</span>
<span class="sd">		:param root: the root node reference</span>
<span class="sd">		:type root: Node</span>
<span class="sd">		:param array: (optional) if provided, a tree, in the form of nested lists</span>
<span class="sd">		:type array:  tuple</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">=-</span><span class="mi">1</span>

		<span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">update_from_array</span><span class="p">(</span> <span class="n">array</span> <span class="p">)</span></div>


	<span class="c1">################## TODO #####################################</span>

<div class="viewcode-block" id="BinaryTree.preorder_walk"><a class="viewcode-back" href="../index.html#bst_skeleton.BinaryTree.preorder_walk">[docs]</a>	<span class="k">def</span> <span class="nf">preorder_walk</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. _preorder_walk:</span>

<span class="sd">		Perform a preorder tree walk.</span>

<span class="sd">		.. todo::</span>
<span class="sd">			Implement the method, using CLRS3, 12.1 as an inspiration. Do not simply print the nodes, but return a list with the node keys in the desired order.</span>
<span class="sd">				</span>
<span class="sd">			1. In this function, write a nested, recursive procedure, that takes a node as a parameter and walks the tree rooted at this node preorder. </span>
<span class="sd">			2. In a second step, *call* the inner procedure, with the root_ of this tree as the actual parameter. Do not forget to return the list</span>

<span class="sd">			There are 2 ways to populate the list. See this class&#39; description_.</span>

<span class="sd">		:return: list of all visited nodes, preorder</span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">pass</span></div>
	
<div class="viewcode-block" id="BinaryTree.postorder_walk"><a class="viewcode-back" href="../index.html#bst_skeleton.BinaryTree.postorder_walk">[docs]</a>	<span class="k">def</span> <span class="nf">postorder_walk</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. _postorder_walk:</span>
<span class="sd">		</span>
<span class="sd">		Perform a postorder tree walk.</span>

<span class="sd">		.. todo::</span>
<span class="sd">			Implement the method, using CLRS3, 12.1 as an inspiration. Do not simply print the node, but return a list with the node keys in the desired order.</span>

<span class="sd">			1. In this function, write a nested, recursive procedure, that takes a node as a parameter and walks the tree rooted at this node postorder. </span>
<span class="sd">			2. In a second step, *call* the inner procedure, with the root_ of this tree as the actual parameter. Do not forget to return the list</span>

<span class="sd">			There are 2 ways to populate the list. See this class&#39; description_.</span>

<span class="sd">		:return: list of all visited nodes, postorder</span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">pass</span></div>
	

<div class="viewcode-block" id="BinaryTree.is_bst"><a class="viewcode-back" href="../index.html#bst_skeleton.BinaryTree.is_bst">[docs]</a>	<span class="k">def</span> <span class="nf">is_bst</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		.. _is_bst:</span>

<span class="sd">		Check for BST property, recursively.</span>

<span class="sd">		.. todo::</span>
<span class="sd">		</span>
<span class="sd">			Write the procedure. The following is a common programming pattern when using recursion:</span>

<span class="sd">			1. In this function, write a nested, recursive procedure, that takes a node `n` as a parameter and returns `True` if the tree rooted at `n` meets the BST property, and `False` otherwise.</span>
<span class="sd">			2. In a second step, *call* the inner procedure, with the root_ of this tree as the first actual parameter, and other parameters as needed. Do not forget to return!</span>
<span class="sd">		</span>
<span class="sd">			CLRS3, Exercise 12.2.1 might be a good starting point: when you walk down the tree recursively, what should you keep track of in order to check whether the BST property holds for the current node?</span>

<span class="sd">		:return: True if this tree is a Binary Search Tree; False otherwise.</span>
<span class="sd">		:rtype: bool</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">pass</span></div>


	<span class="c1">#############################################################</span>

	<span class="c1">## NON-ESSENTIAL FUNCTIONS: FOR TEACHING/TESTING PURPOSE</span>

	<span class="k">def</span> <span class="nf">update_from_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span>  <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Build a binary tree from nested tuples </span>
<span class="sd">		</span>
<span class="sd">		Ex. BinaryTree().update_from_array( ( 1,(2,3,4),(5,None,6) ) yields the following tree::</span>
<span class="sd">			</span>
<span class="sd">					1</span>
<span class="sd">			     __________/\________</span>
<span class="sd">			    2                   5</span>
<span class="sd">			  _/\                    \</span>
<span class="sd">			 3   4                    6</span>
<span class="sd">		</span>

<span class="sd">		:param array: a list of the form ( key, ( left subtree ), (right subtree ))</span>
<span class="sd">		:type array: tuple</span>
<span class="sd">		&quot;&quot;&quot;</span>
	
		<span class="k">def</span> <span class="nf">read_rec</span><span class="p">(</span> <span class="n">triplet</span> <span class="p">):</span>
			<span class="sd">&quot;&quot;&quot; Inner function: build a (node,depth) pair from a triplet (parenet,left,right) &quot;&quot;&quot;</span>
			<span class="c1"># base case: a leaf</span>
			<span class="k">if</span> <span class="n">triplet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">return</span> <span class="kc">None</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">triplet</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
			<span class="c1"># parent node</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span> <span class="n">triplet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
			<span class="c1"># children</span>
			<span class="n">data_left</span> <span class="o">=</span> <span class="n">read_rec</span><span class="p">(</span> <span class="n">triplet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
			<span class="n">data_right</span> <span class="o">=</span> <span class="n">read_rec</span><span class="p">(</span> <span class="n">triplet</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
			<span class="k">if</span> <span class="n">data_left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">add_left</span> <span class="p">(</span> <span class="n">data_left</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">data_right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">add_right</span> <span class="p">(</span> <span class="n">data_right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="c1"># returning a pair:</span>
			<span class="c1"># - current node pointer</span>
			<span class="c1"># - height, as computed from children&#39;s heights</span>
			<span class="k">if</span> <span class="n">data_left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">data_right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">data_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">data_right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">data_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">data_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">data_right</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">read_rec</span><span class="p">(</span> <span class="n">array</span> <span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">data</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">update_depth</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="k">return</span> <span class="bp">self</span>
		
	<span class="k">def</span> <span class="nf">update_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Update the depth attribute on the given node, and all its</span>
<span class="sd">		descendants</span>

<span class="sd">		:param node: root of the subtree to be updated</span>
<span class="sd">		:param depth: value of the new depth attribute</span>
<span class="sd">		:type node: Node</span>
<span class="sd">		:type depth: int</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">node</span><span class="o">.</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">update_depth</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">update_depth</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="BinaryTree.display"><a class="viewcode-back" href="../index.html#bst_skeleton.BinaryTree.display">[docs]</a>	<span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Breadth-first tree-walking, displaying the nodes on the console</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
		
		<span class="c1"># overall width is function of the height of the tree</span>
		<span class="n">root_pos</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		
		<span class="n">prev_depth</span><span class="o">=</span><span class="mi">0</span>
		<span class="n">prev_pos</span><span class="o">=</span><span class="mi">0</span>
		<span class="n">edge_def</span><span class="o">=</span><span class="p">[]</span>
		<span class="n">label_offset</span><span class="o">=</span><span class="mi">0</span>
		<span class="n">consumed</span><span class="o">=</span><span class="mi">0</span>
		<span class="n">q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span><span class="n">root_pos</span><span class="p">))</span>
		<span class="k">while</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
			<span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_pos</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>

			<span class="c1"># starting a row: using absolute position for offset</span>
			<span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">depth</span> <span class="o">!=</span> <span class="n">prev_depth</span> <span class="ow">or</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
				<span class="n">prev_depth</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">depth</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">n_pos</span><span class="o">-</span><span class="mi">1</span>
				<span class="n">label_offset</span><span class="o">=</span><span class="mi">0</span>

				<span class="c1"># converting edge boundaries into a string</span>
				<span class="nb">print</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_string</span><span class="p">(</span><span class="n">edge_def</span><span class="p">)</span> <span class="p">)</span>
				<span class="n">edge_def</span><span class="o">=</span><span class="p">[]</span>

			<span class="c1"># in a row: computing an offset from last position</span>
			<span class="c1"># -2 takes care of label already entered</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">n_pos</span> <span class="o">-</span> <span class="n">prev_pos</span> <span class="o">-</span> <span class="n">label_offset</span>

			<span class="n">prev_pos</span> <span class="o">=</span> <span class="n">n_pos</span>
			<span class="n">label_offset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>

			<span class="c1"># display the node</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">offset</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">n</span><span class="o">.</span><span class="n">key</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

			
			<span class="c1"># enqueue children, computing edge boundaries at the same time</span>
			<span class="n">edge_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">root_pos</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">))))</span>
			<span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_pos</span> <span class="o">-</span> <span class="n">edge_length</span><span class="p">))</span> <span class="p">)</span>
				<span class="n">edge_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_pos</span> <span class="o">-</span> <span class="n">edge_length</span><span class="p">),</span><span class="n">n_pos</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_pos</span> <span class="o">+</span> <span class="n">edge_length</span><span class="p">))</span> <span class="p">)</span>
				<span class="n">edge_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="n">n_pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n_pos</span> <span class="o">+</span> <span class="n">edge_length</span><span class="p">))</span> <span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>			</div>
		
	<span class="k">def</span> <span class="nf">edge_string</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">definition</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Build a string according to edge specs &quot;&quot;&quot;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">string_arr</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">definition</span><span class="p">:</span>

			<span class="n">string_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;L&#39;</span><span class="p">:</span>
				<span class="n">string_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">string_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span> <span class="p">)</span>
			<span class="n">string_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;_&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;L&#39;</span><span class="p">:</span>
				<span class="n">string_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;/&#39;</span> <span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">string_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39; &#39;</span> <span class="p">)</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">string_arr</span> <span class="p">)</span></div>
			
					
<span class="k">class</span> <span class="nc">BinaryTree_UnitTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>


	<span class="k">def</span> <span class="nf">test_preorder_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="s2">&quot; Test pre-order tree walk &quot;&quot;&quot;</span>	
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">14</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">67</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test pre-order walk&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">preorder_walk</span><span class="p">(),</span>  <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">67</span><span class="p">])</span>
	
	<span class="k">def</span> <span class="nf">test_postorder_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="s2">&quot; Test post-order tree walk &quot;&quot;&quot;</span>	
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">14</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">67</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test post-order walk&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">postorder_walk</span><span class="p">(),</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
	

	<span class="k">def</span> <span class="nf">test_is_bst_true_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Test BST property true: note that keys might be equal &quot;&quot;&quot;</span>
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">14</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">67</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test BST true&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">is_bst</span><span class="p">()</span> <span class="p">)</span>

	
	<span class="k">def</span> <span class="nf">test_is_bst_true_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Test BST property: leaf &quot;&quot;&quot;</span>
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test BST true: testing leaf&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">is_bst</span><span class="p">()</span> <span class="p">)</span>
		

	<span class="k">def</span> <span class="nf">test_is_bst_false_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Test BST property false: property is broken between R child and parent</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">12</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="mi">23</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test BST false: R child/parent&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">is_bst</span><span class="p">()</span> <span class="p">)</span>

	<span class="k">def</span> <span class="nf">test_is_bst_false_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Test BST property false: property is broken between L child and parent</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="kc">None</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test BST false: L child/parent&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">is_bst</span><span class="p">()</span> <span class="p">)</span>

	<span class="k">def</span> <span class="nf">test_is_bst_false_3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Test BST property false: property is broken between R descendant and ancestor</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="mi">25</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test BST false: R descendant/ancestor&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">is_bst</span><span class="p">()</span> <span class="p">)</span>


	<span class="k">def</span> <span class="nf">test_is_bst_false_4</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; Test BST property false: property is broken between R descendant and ancestor</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">bst</span><span class="o">=</span><span class="n">BinaryTree</span><span class="p">(</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,(</span><span class="mi">16</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="kc">None</span><span class="p">))),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">19</span> <span class="p">,(</span><span class="mi">24</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="mi">25</span><span class="p">))))</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;test BST false: L descendant/ancestor&quot;</span><span class="p">)</span>
		<span class="n">bst</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span> <span class="n">bst</span><span class="o">.</span><span class="n">is_bst</span><span class="p">()</span> <span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
        <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
        <span class="n">main</span><span class="p">()</span>


	
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Binary Search Tree 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, NPR.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.9.
    </div>
  </body>
</html>